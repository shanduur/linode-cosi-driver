// Copyright 2023 Akamai Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package featurebuilder

import (
	"context"
	"strings"
	"testing"

	"sigs.k8s.io/e2e-framework/pkg/envconf"
	"sigs.k8s.io/e2e-framework/pkg/features"
)

// Label struct represents a label with two fields - Key and Value.
type Label struct {
	Key, Value string
}

// LabelMatrix struct represents a set of labels with two fields - Key, ValueArray. It stores the label's key and a
// list of possible values for generating Label structs.
type LabelMatrix struct {
	Key         string
	ValueMatrix []string
}

// CommonAssesments type is a map that associates assessment function names as keys and the corresponding functions as
// values. Each function shares signature with sigs.k8s.io/e2e-framework/pkg/internal/types.StepFunc .
type CommonAssesments map[string]func(ctx context.Context, t *testing.T, cfg *envconf.Config) context.Context

// setupContextFromLabels takes in a set of Label objects and returns a closure function that can be used to modify the
// context.Context. This modified context is then returned by the closure.
func setupContextFromLabels(labels ...Label) func(ctx context.Context, t *testing.T, c *envconf.Config) context.Context {
	return func(ctx context.Context, t *testing.T, c *envconf.Config) context.Context {
		for _, l := range labels {
			ctx = context.WithValue(ctx, l.Key, l.Value)
		}

		return ctx
	}
}

// New creates a new feature builder with given prefix and labels, while generating test name based on the label values.
func New(prefix string, labels ...Label) *features.FeatureBuilder {
	name := []string{}

	if prefix != "" {
		name = append(name, prefix)
	}

	for _, l := range labels {
		name = append(name, l.Value)
	}

	fb := features.New(strings.Join(name, "_"))

	for _, l := range labels {
		fb = fb.WithLabel(l.Key, l.Value)
	}

	return fb.WithSetup("fill the context", setupContextFromLabels(labels...))
}

// generateCombinations is used to generate all possible feature combinations from a set of LabelMatrix objects. It
// utilizes recursion to generate these combinations.
func generateCombinations(
	labelIndex int,
	prefix string,
	labels []LabelMatrix,
	currentCombination []Label,
	combinations *[]*features.FeatureBuilder,
) {
	if labelIndex == len(labels) {
		*combinations = append(*combinations, New(prefix, currentCombination...))
		return
	}

	// iterates over the values in the ValueMatrix of the current labelIndex. This allows for different combinations to
	// be generated by adding each value to the currentCombination slice.
	for _, value := range labels[labelIndex].ValueMatrix {
		// update the currentCombination at the current labelIndex with the new value and recursively call
		// generateCombinations with the next index. This allows for the generation of combinations for the remaining
		// labels.
		currentCombination[labelIndex] = Label{Key: labels[labelIndex].Key, Value: value}
		generateCombinations(labelIndex+1, prefix, labels, currentCombination, combinations)
	}
}

// NewMatrix creates a set of features.FeatureBuilder objects, each representing a unique
// combination of the provided labels with the applied assessments.
func NewMatrix(
	prefix string,
	labels []LabelMatrix,
	assesments CommonAssesments,
) []*features.FeatureBuilder {
	var combinations []*features.FeatureBuilder

	generateCombinations(0, prefix, labels, make([]Label, len(labels)), &combinations)

	for _, fb := range combinations {
		for name, fn := range assesments {
			fb.Assess(name, fn)
		}
	}

	return combinations
}
